from goat.decorators.tool import Tool
import os
from exa_py import Exa
from .parameters import SearchInput
from typing import Optional
class ExaSearchService:
    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key or os.getenv("EXA_API_KEY")
        if not self.api_key:
            raise ValueError("EXA_API_KEY must be provided either through constructor or environment variable")
        self.client = Exa(self.api_key)

    @Tool({
        "description": "Perform web search using the Exa API to find relevant information",
        "parameters_schema": SearchInput
    })
    async def perform_web_search(self, parameters: dict):
        """
        Perform web search using the Exa API and fetch page contents.
        
        Args:
            parameters (dict): Dictionary containing SearchInput parameters:
                - query (str): The search query to look up information
                - num_results (int): Number of results to return (1-10)
                - max_chars (int): Maximum characters per result (100-5000)
        
        Returns:
            dict: A dictionary containing the search results, page contents, and status
        """
        try:
            query = parameters["query"]
            num_results = parameters.get("num_results", 3)
            max_chars = parameters.get("max_chars", 1000)

            print(f"Performing search with query: {query}, num_results: {num_results}, max_chars: {max_chars}")

            response = self.client.search_and_contents(
                query,
                use_autoprompt=True,
                num_results=num_results,
                text={"max_characters": max_chars}
            )

            print(f"Raw API response: {response}")

            if not response.results:
                return {
                    "status": "success",
                    "message": f"No results found for query: {query}",
                    "results": []
                }

            results = []
            for result in response.results:
                results.append({
                    "title": result.title,
                    "url": result.url,
                    "published_date": result.published_date or "Date not available",
                    "score": result.score,
                    "content": result.text[:max_chars] if result.text else "Content not available"
                })

            return {
                "status": "success",
                "message": f"Found {len(results)} results for query: {query}",
                "results": results
            }

        except Exception as error:
            error_details = {
                "type": type(error).__name__,
                "message": str(error),
            }
            if hasattr(error, 'response'):
                error_details["status_code"] = error.response.status_code
                error_details["response_text"] = error.response.text
            print(f"Error details: {error_details}")
            return {
                "status": "error",
                "message": f"Error performing search: {error_details}",
                "results": []
            }
